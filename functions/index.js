// index.js (р╣Ар╕зр╕нр╕гр╣Мр╕Кр╕▒р╕Щ Express.js р╕кр╕│р╕лр╕гр╕▒р╕Ъ AWS Lambda р╣Бр╕ер╕░р╣Бр╕Юр╕ер╕Хр╕Яр╕нр╕гр╣Мр╕бр╕нр╕╖р╣Ир╕Щр╣Ж)
// р╣Вр╕Др╣Йр╕Фр╕Щр╕╡р╣Йр╕кр╕▓р╕бр╕▓р╕гр╕Цр╕гр╕▒р╕Щр╕Ър╕Щр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╣Ар╕Юр╕╖р╣Ир╕нр╕Чр╕Фр╕кр╕нр╕Ъ р╣Бр╕ер╕░ deploy р╕Вр╕╢р╣Йр╕Щ AWS Lambda р╣Др╕Фр╣Йр╣Вр╕Фр╕вр╕Хр╕гр╕З

// --- р╕кр╣Ир╕зр╕Щр╕Чр╕╡р╣И 1: Imports ---
import express from "express"
import serverless from "serverless-http"
import line from "./utils/line.js"
import gemini from "./utils/gemini.js"
import imagetotext from "./utils/imagetotext.js"
import sharp from "sharp"
import NodeCache from "node-cache"
import validator from "validator"
import speech from "@google-cloud/speech"
import path from "path"
import os from "os"
import fs from "fs"
import ffmpeg from "fluent-ffmpeg"
import PQueue from "p-queue"

// --- р╕кр╣Ир╕зр╕Щр╕Чр╕╡р╣И 2: р╕Бр╕▓р╕гр╕Хр╕▒р╣Йр╕Зр╕Др╣Ир╕▓р╕Чр╕╡р╣Ир╕Вр╕╢р╣Йр╕Щр╕Бр╕▒р╕Ър╕кр╕ар╕▓р╕Юр╣Бр╕зр╕Фр╕ер╣Йр╕нр╕б (Environment-dependent Configuration) ---

// р╕Хр╕▒р╣Йр╕Зр╕Др╣Ир╕▓ Path р╕Вр╕нр╕З FFMPEG р╣Бр╕Ър╕Ър╣Др╕Фр╕Щр╕▓р╕бр╕┤р╕Б
// р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕зр╣Ир╕▓р╕Бр╕│р╕ер╕▒р╕Зр╕гр╕▒р╕Щр╕Ър╕Щ AWS Lambda р╕лр╕гр╕╖р╕нр╣Др╕бр╣И
if (process.env.AWS_LAMBDA_FUNCTION_NAME) {
  // р╕Ър╕Щ Lambda, binary file р╕Ир╕▓р╕Б Layer р╕Ир╕░р╕нр╕вр╕╣р╣Ир╕Чр╕╡р╣И /opt/bin/
  // **р╕кр╕│р╕Др╕▒р╕Н:** р╕Хр╣Йр╕нр╕Зр╣Ар╕Юр╕┤р╣Ир╕б FFMPEG Lambda Layer р╣Гр╕Щр╕Бр╕▓р╕гр╕Хр╕▒р╣Йр╕Зр╕Др╣Ир╕▓р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щ Lambda р╕Вр╕нр╕Зр╕Др╕╕р╕У
  ffmpeg.setFfmpegPath("/opt/bin/ffmpeg")
} else {
  // р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕▓р╕гр╕гр╕▒р╕Щр╕Ър╕Щр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕З (Local Development) р╕Ир╕░р╣Гр╕Кр╣Йр╕Ир╕▓р╕Б node_modules
  import("@ffmpeg-installer/ffmpeg").then((ffmpegInstaller) => {
    ffmpeg.setFfmpegPath(ffmpegInstaller.path)
  })
}

// Instantiates a client р╕кр╕│р╕лр╕гр╕▒р╕Ъ Google Cloud Speech-to-Text
const client = new speech.SpeechClient()

// р╕кр╕гр╣Йр╕▓р╕З instance р╕Вр╕нр╕З NodeCache р╣Бр╕ер╕░ PQueue
const webhookCache = new NodeCache({
  stdTTL: 600,
  checkperiod: 120,
  useClones: false,
})
const queue = new PQueue({ concurrency: 3 })

// --- р╕кр╣Ир╕зр╕Щр╕Чр╕╡р╣И 3: р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щ Helper р╣Бр╕ер╕░ Business Logic р╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Ф (р╕Др╕▒р╕Фр╕ер╕нр╕Бр╕бр╕▓р╕Ир╕▓р╕Бр╣Др╕Яр╕ер╣Мр╣Ар╕Фр╕┤р╕б) ---

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ URL
const isUrl = (string) => validator.isURL(string, { require_protocol: true })

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕гр╕░р╕Ър╕Ъ
const getSystemInfo = () => {
  const uptimeInSeconds = os.uptime()
  const days = Math.floor(uptimeInSeconds / 86400)
  const hours = Math.floor((uptimeInSeconds % 86400) / 3600)
  const minutes = Math.floor((uptimeInSeconds % 3600) / 60)
  const seconds = Math.floor(uptimeInSeconds % 60)
  const totalMemory = os.totalmem()
  const freeMemory = os.freemem()
  const usedMemory = totalMemory - freeMemory
  const totalMemoryGB = (totalMemory / 1024 ** 3).toFixed(2)
  const usedMemoryGB = (usedMemory / 1024 ** 3).toFixed(2)
  const freeMemoryGB = (freeMemory / 1024 ** 3).toFixed(2)
  const memoryUsagePercent = ((usedMemory / totalMemory) * 100).toFixed(1)
  const cpus = os.cpus()
  const cpuModel = cpus[0].model.replace(/\s+/g, " ").trim()
  const cpuSpeed = (cpus[0].speed / 1000).toFixed(2)
  const loadAvg = os.loadavg()
  const cpuLoadPercent = ((loadAvg[0] * 100) / cpus.length).toFixed(1)

  if (parseFloat(cpuLoadPercent) > 80) {
    console.warn("CPU Load р╕кр╕╣р╕Зр╣Ар╕Бр╕┤р╕Щр╣Др╕Ы! р╕нр╕▓р╕Ир╕бр╕╡р╕Ьр╕ер╕Хр╣Ир╕нр╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Ю.")
  }

  return {
    NodeVersion: process.version,
    OS: `${os.type()} ${os.arch()} ${os.release()}`,
    Platform: os.platform(),
    CPU: {
      Model: cpuModel,
      Speed: `${cpuSpeed} GHz`,
      Cores: cpus.length,
      LoadPercent: `${cpuLoadPercent}%`,
    },
    Memory: {
      Total: `${totalMemoryGB} GB`,
      Used: `${usedMemoryGB} GB`,
      Free: `${freeMemoryGB} GB`,
      UsagePercent: `${memoryUsagePercent}%`,
    },
    Uptime: `${days}d ${hours}h ${minutes}m ${seconds}s`,
    SystemUptime: process.uptime().toFixed(0) + "s",
  }
}

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕гр╣Йр╕▓р╕З Flex Message р╣Бр╕кр╕Фр╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕гр╕░р╕Ър╕Ъ
const createSystemInfoFlex = (systemInfo) => ({
  type: "flex",
  altText: "р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕гр╕░р╕Ър╕Ър╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М ЁЯЦея╕П",
  contents: {
    type: "bubble",
    size: "mega",
    body: {
      type: "box",
      layout: "vertical",
      contents: [
        {
          type: "text",
          text: "р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕гр╕░р╕Ър╕Ър╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М ЁЯЦея╕П",
          weight: "bold",
          size: "xl",
          align: "center",
          margin: "md",
          color: "#ffffff",
        },
        { type: "separator", margin: "md" },
        {
          type: "box",
          layout: "vertical",
          margin: "lg",
          spacing: "sm",
          contents: [
            {
              type: "text",
              text: `OS: ${systemInfo.OS}`,
              color: "#ffffff",
              wrap: true,
            },
            {
              type: "text",
              text: `Platform: ${systemInfo.Platform}`,
              color: "#ffffff",
              wrap: true,
            },
            {
              type: "text",
              text: `Node.js: ${systemInfo.NodeVersion}`,
              color: "#ffffff",
              wrap: true,
            },
            {
              type: "text",
              text: `CPU: ${systemInfo.CPU.Model}`,
              color: "#ffffff",
              wrap: true,
            },
            {
              type: "text",
              text: `CPU Speed: ${systemInfo.CPU.Speed}`,
              color: "#ffffff",
              wrap: true,
            },
            {
              type: "text",
              text: `CPU Cores: ${systemInfo.CPU.Cores}`,
              color: "#ffffff",
              wrap: true,
            },
            {
              type: "text",
              text: `CPU Load: ${systemInfo.CPU.LoadPercent}`,
              color: "#ffffff",
              wrap: true,
            },
            {
              type: "text",
              text: `Memory Total: ${systemInfo.Memory.Total}`,
              color: "#ffffff",
              wrap: true,
            },
            {
              type: "text",
              text: `Memory Used: ${systemInfo.Memory.Used} (${systemInfo.Memory.UsagePercent})`,
              color: "#ffffff",
              wrap: true,
            },
            {
              type: "text",
              text: `Memory Free: ${systemInfo.Memory.Free}`,
              color: "#ffffff",
              wrap: true,
            },
            {
              type: "text",
              text: `System Uptime: ${systemInfo.Uptime}`,
              color: "#ffffff",
              wrap: true,
            },
          ],
        },
      ],
    },
    styles: { body: { backgroundColor: "#2e3b55" } },
  },
})

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╣Бр╕Ыр╕ер╕З .m4a р╣Ар╕Ыр╣Зр╕Щ .wav
const convertM4aToWav = async (m4aLocalFile, wavLocalFile) =>
  new Promise((resolve, reject) => {
    ffmpeg(m4aLocalFile)
      .inputOptions("-y")
      .outputOptions("-preset ultrafast")
      .toFormat("wav")
      .audioCodec("pcm_s16le")
      .audioChannels(1)
      .audioFrequency(16000)
      .on("end", () => {
        console.log("тЬЕ FFmpeg: Conversion finished")
        if (fs.existsSync(m4aLocalFile)) fs.unlinkSync(m4aLocalFile)
        resolve()
      })
      .on("error", (err) => {
        console.error("тЭМ FFmpeg error:", err.message)
        if (fs.existsSync(m4aLocalFile)) fs.unlinkSync(m4aLocalFile)
        if (fs.existsSync(wavLocalFile)) fs.unlinkSync(wavLocalFile)
        reject(err)
      })
      .save(wavLocalFile)
  })

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ъ Google Cloud Speech-to-Text
const transcribeSpeech = async (wavFilename) => {
  const audio = { content: fs.readFileSync(wavFilename).toString("base64") }
  const config = {
    encoding: "LINEAR16",
    sampleRateHertz: 16000,
    languageCode: "th-TH",
    alternativeLanguageCodes: ["en-US"],
    model: "latest_long",
    enableWordConfidence: true,
    useEnhanced: true,
  }
  const request = { audio, config }
  const [response] = await client.recognize(request)
  const transcription = response.results
    .map((result) => result.alternatives[0].transcript)
    .join("\n")
  console.log(`р╕Ир╕│р╕Щр╕зр╕Щр╕Хр╕▒р╕зр╕нр╕▒р╕Бр╕йр╕г: ${transcription.length}`)
  return transcription
}

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Хр╣Йр╕нр╕Щр╕гр╕▒р╕Ър╕кр╕бр╕▓р╕Кр╕┤р╕Бр╣Гр╕лр╕бр╣И
const sendWelcomeMessage = async (event) => {
  const promises = event.joined.members.map(async (member) => {
    if (member.type === "user") {
      await line.reply(event.replyToken, [
        {
          type: "textV2",
          text: "р╕кр╕зр╕▒р╕кр╕Фр╕╡р╕Др╕╕р╕УтЬи {user1}! р╕вр╕┤р╕Щр╕Фр╕╡р╕Хр╣Йр╕нр╕Щр╕гр╕▒р╕Ъ \n р╕Чр╕╕р╕Бр╕Др╕Щ {everyone} ЁЯТХ р╕бр╕╡р╣Ар╕Юр╕╖р╣Ир╕нр╕Щр╣Гр╕лр╕бр╣Ир╣Ар╕Вр╣Йр╕▓р╕бр╕▓ р╕нр╕вр╣Ир╕▓р╕ер╕╖р╕бр╕Чр╕▒р╕Бр╕Чр╕▓р╕вр╕Бр╕▒р╕Щр╕Щр╕░ЁЯЩМ",
          substitution: {
            user1: {
              type: "mention",
              mentionee: { type: "user", userId: member.userId },
            },
            everyone: { type: "mention", mentionee: { type: "all" } },
          },
        },
      ])
    }
  })
  await Promise.all(promises)
}

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Хр╣Йр╕нр╕Щр╕гр╕▒р╕Ър╣Ар╕бр╕╖р╣Ир╕нр╕бр╕╡р╕Ьр╕╣р╣Йр╕Хр╕┤р╕Фр╕Хр╕▓р╕бр╣Гр╕лр╕бр╣И
const sendWelcomeFlex = async (event, userId) => {
  try {
    const profile = await line.getProfile(userId)
    const welcomeFlex = {
      type: "flex",
      altText: event.follow?.isUnblocked
        ? "р╕вр╕┤р╕Щр╕Фр╕╡р╕Хр╣Йр╕нр╕Щр╕гр╕▒р╕Ър╕Бр╕ер╕▒р╕Ър╕бр╕▓р╕нр╕╡р╕Бр╕Др╕гр╕▒р╣Йр╕З! ЁЯШБ"
        : `р╕кр╕зр╕▒р╕кр╕Фр╕╡р╕Др╣Ир╕░ ЁЯЩМ р╕Йр╕▒р╕Щр╕Кр╕╖р╣Ир╕н Panya AI р╕Йр╕▒р╕Щр╕Юр╕гр╣Йр╕нр╕бр╕Кр╣Ир╕зр╕вр╕кр╕гр╕╕р╕Ыр╣Ар╕Щр╕╖р╣Йр╕нр╕лр╕▓р╣Гр╕лр╣Йр╕нр╣Ир╕▓р╕Щр╕Зр╣Ир╕▓р╕вр╣Бр╕ер╕░р╕гр╕зр╕Фр╣Ар╕гр╣Зр╕з р╣Ар╕Юр╕╡р╕вр╕Зр╕кр╣Ир╕З р╕ер╕┤р╕Зр╕Бр╣М, р╕гр╕╣р╕Ыр╕ар╕▓р╕Ю р╕лр╕гр╕╖р╕нр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕бр╕▓р╣Др╕Фр╣Йр╣Ар╕ер╕вр╕Др╣Ир╕░ ЁЯШК`,
      contents: {
        type: "bubble",
        size: "mega",
        hero: {
          type: "image",
          url: profile?.pictureUrl || "https://i.postimg.cc/brr7Fmw9/user.png",
          size: "full",
          aspectRatio: "20:13",
          aspectMode: "cover",
        },
        body: {
          type: "box",
          layout: "vertical",
          contents: [
            {
              type: "text",
              text:
                "р╕Кр╕╖р╣Ир╕нр╕Ьр╕╣р╣Йр╣Гр╕Кр╣Й ЁЯк┤ : " + (profile?.displayName || "Unknown User"),
              weight: "bold",
              size: "lg",
              margin: "md",
              align: "center",
              color: "#F5F7F8",
            },
            {
              type: "text",
              text: event.follow?.isUnblocked
                ? "р╕вр╕┤р╕Щр╕Фр╕╡р╕Хр╣Йр╕нр╕Щр╕гр╕▒р╕Ър╕Бр╕ер╕▒р╕Ър╕бр╕▓р╕нр╕╡р╕Бр╕Др╕гр╕▒р╣Йр╕З! ЁЯШБ"
                : `р╕кр╕зр╕▒р╕кр╕Фр╕╡р╕Др╣Ир╕░ р╕Йр╕▒р╕Щр╕Кр╕╖р╣Ир╕н Panya AI р╕Йр╕▒р╕Щр╕кр╕▓р╕бр╕▓р╕гр╕Цр╕Кр╣Ир╕зр╕вр╕Др╕╕р╕Ур╕кр╕гр╕╕р╕Ыр╣Ар╕Щр╕╖р╣Йр╕нр╕лр╕▓р╣Гр╕лр╣Йр╕нр╣Ир╕▓р╕Щр╕Зр╣Ир╕▓р╕вр╣Бр╕ер╕░р╕гр╕зр╕Фр╣Ар╕гр╣Зр╕зр╕Др╣Ир╕░ ЁЯШК`,
              wrap: true,
              size: "md",
              color: "#F5F7F8",
              margin: "lg",
              align: "center",
            },
            {
              type: "text",
              text:
                "р╕зр╕▒р╕Щр╕Чр╕╡р╣И ЁЯУЕ : " +
                new Date().toLocaleDateString("th-TH", {
                  year: "numeric",
                  month: "long",
                  day: "numeric",
                }),
              size: "md",
              color: "#F5F7F8",
              margin: "lg",
              align: "center",
            },
          ],
        },
        styles: { body: { backgroundColor: "#484c6c" } },
      },
    }
    const stickerMessage = {
      type: "sticker",
      packageId: "11539",
      stickerId: "52114114",
    }
    await line.reply(event.replyToken, [welcomeFlex, stickerMessage])
  } catch (err) {
    console.error("Error getting profile:", err)
  }
}

// р╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Др╕╣р╣Ир╕бр╕╖р╕нр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╣Бр╕Кр╕Чр╕Ър╕нр╕Ч AI (Flex Message)
const manualChatbot = {
  type: "flex",
  altText: "р╕зр╕┤р╕Шр╕╡р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╣Бр╕Кр╕Чр╕Ър╕нр╕Ч AI ЁЯУЪ",
  contents: {
    type: "bubble",
    header: {
      type: "box",
      layout: "vertical",
      contents: [
        {
          type: "text",
          text: "р╕зр╕┤р╕Шр╕╡р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╣Бр╕Кр╕Чр╕Ър╕нр╕Ч AI ЁЯУЪ",
          align: "center",
          weight: "bold",
          size: "lg",
          color: "#FFFFFF",
        },
      ],
      backgroundColor: "#7E5CAD",
    },
    body: {
      type: "box",
      layout: "vertical",
      contents: [
        {
          type: "text",
          text: "р╣Бр╕Кр╕Чр╕Ър╕нр╕Чр╕Щр╕╡р╣Йр╕кр╕▓р╕бр╕▓р╕гр╕Цр╕Хр╕нр╕Ър╕кр╕Щр╕нр╕Зр╕Хр╣Ир╕нр╕Др╕зр╕▓р╕бр╕Хр╣Йр╕нр╕Зр╕Бр╕▓р╕гр╕Чр╕╡р╣Ир╕лр╕ер╕▓р╕Бр╕лр╕ер╕▓р╕вр╕Ьр╣Ир╕▓р╕Щр╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕Бр╕▓р╕гр╕Чр╕│р╕Зр╕▓р╕Щр╕Фр╕▒р╕Зр╕Щр╕╡р╣Й :",
          wrap: true,
          margin: "md",
        },
        {
          type: "box",
          layout: "vertical",
          margin: "lg",
          spacing: "sm",
          contents: [
            {
              type: "box",
              layout: "baseline",
              contents: [
                {
                  type: "text",
                  text: "1. р╕Хр╕нр╕Ър╕Др╕│р╕Цр╕▓р╕бр╣Бр╕ер╕░р╕Др╣Йр╕Щр╕лр╕▓р╕Вр╣Йр╕нр╕бр╕╣р╕еЁЯФО :",
                  weight: "bold",
                  flex: 0,
                },
              ],
            },
            {
              type: "text",
              text: 'р╕Юр╕┤р╕бр╕Юр╣Мр╕Др╕│р╕Цр╕▓р╕бр╕лр╕гр╕╖р╕нр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Чр╕╡р╣Ир╕Хр╣Йр╕нр╕Зр╕Бр╕▓р╕гр╕Чр╕гр╕▓р╕Ъ р╣Ар╕Кр╣Ир╕Щ "р╕гр╕░р╕Ър╕Ър╕кр╕╕р╕гр╕┤р╕вр╕░р╕бр╕╡р╕Бр╕╡р╣Ир╕Фр╕▓р╕зр╣Ар╕Др╕гр╕▓р╕░р╕лр╣М?" р╣Бр╕Кр╕Чр╕Ър╕нр╕Чр╕Ир╕░р╕Хр╕нр╕Ър╕Др╕│р╕Цр╕▓р╕бр╕лр╕гр╕╖р╕нр╣Гр╕лр╣Йр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Ар╕Юр╕┤р╣Ир╕бр╣Ар╕Хр╕┤р╕бр╕Чр╕▒р╕Щр╕Чр╕╡',
              wrap: true,
              margin: "sm",
            },
            {
              type: "box",
              layout: "baseline",
              contents: [
                {
                  type: "text",
                  text: "2. р╕кр╕гр╕╕р╕Ыр╣Ар╕Щр╕╖р╣Йр╕нр╕лр╕▓р╕Ир╕▓р╕Бр╣Др╕Яр╕ер╣Мр╕гр╕╣р╕Ыр╕ар╕▓р╕ЮЁЯЦ╝я╕П :",
                  weight: "bold",
                  flex: 0,
                },
              ],
            },
            {
              type: "text",
              text: 'р╕нр╕▒р╕Ыр╣Вр╕лр╕ер╕Фр╕гр╕╣р╕Ыр╕ар╕▓р╕Юр╕Чр╕╡р╣Ир╕бр╕╡р╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕лр╕гр╕╖р╕нр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕кр╕│р╕Др╕▒р╕Нр╣Вр╕Фр╕вр╕Др╕ер╕┤р╕Бр╕Ыр╕╕р╣Ир╕б "р╕нр╕▒р╕Ыр╣Вр╕лр╕ер╕Фр╕гр╕╣р╕Ыр╕ар╕▓р╕Ю" р╕Ир╕▓р╕Бр╕Щр╕▒р╣Йр╕Щр╣Бр╕Кр╕Чр╕Ър╕нр╕Чр╕Ир╕░р╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╣Бр╕ер╕░р╕кр╕гр╕╕р╕Ыр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╣Гр╕Щр╕ар╕▓р╕Юр╣Гр╕лр╣Й',
              wrap: true,
              margin: "sm",
            },
            {
              type: "box",
              layout: "baseline",
              contents: [
                {
                  type: "text",
                  text: "3. р╕кр╕гр╕╕р╕Ыр╣Ар╕Щр╕╖р╣Йр╕нр╕лр╕▓р╕Ир╕▓р╕Б URL р╕лр╕гр╕╖р╕нр╣Ар╕зр╣Зр╕Ър╣Др╕Лр╕Хр╣МЁЯМП :",
                  weight: "bold",
                  flex: 0,
                },
              ],
            },
            {
              type: "text",
              text: "р╕Др╕▒р╕Фр╕ер╕нр╕Б URL р╣Ар╕зр╣Зр╕Ър╣Др╕Лр╕Хр╣Мр╕Чр╕╡р╣Ир╕Хр╣Йр╕нр╕Зр╕Бр╕▓р╕гр╕Юр╕гр╣Йр╕нр╕бр╕зр╕▓р╕Зр╕ер╕┤р╕Зр╕Бр╣Мр╣Гр╕Щр╣Бр╕Кр╕Ч р╣Бр╕Кр╕Чр╕Ър╕нр╕Чр╕Ир╕░р╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Бр╕ер╕░р╕кр╕гр╕╕р╕Ыр╣Гр╕лр╣Й",
              wrap: true,
              margin: "sm",
            },
            {
              type: "box",
              layout: "baseline",
              contents: [
                {
                  type: "text",
                  text: "4. р╕кр╕гр╕╕р╕Ыр╣Ар╕Щр╕╖р╣Йр╕нр╕лр╕▓р╕Ир╕▓р╕Бр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бЁЯТм :",
                  weight: "bold",
                  flex: 0,
                },
              ],
            },
            {
              type: "text",
              text: "р╕зр╕▓р╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕вр╕▓р╕зр╕Чр╕╡р╣Ир╕Хр╣Йр╕нр╕Зр╕Бр╕▓р╕гр╣Гр╕лр╣Йр╕кр╕гр╕╕р╕Ыр╕ер╕Зр╣Гр╕Щр╣Бр╕Кр╕Ч р╣Бр╕Кр╕Чр╕Ър╕нр╕Чр╕Ир╕░р╕Кр╣Ир╕зр╕вр╕вр╣Ир╕нр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╣Бр╕ер╕░р╕кр╕гр╕╕р╕Ыр╕Ыр╕гр╕░р╣Ар╕Фр╣Зр╕Щр╕кр╕│р╕Др╕▒р╕Н",
              wrap: true,
              margin: "sm",
            },
            {
              type: "box",
              layout: "baseline",
              contents: [
                {
                  type: "text",
                  text: "5. р╕Хр╕нр╕Ър╣Вр╕Хр╣Йр╕Фр╣Йр╕зр╕вр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╣Ар╕кр╕╡р╕вр╕ЗЁЯОЩя╕П :",
                  weight: "bold",
                  flex: 0,
                },
              ],
            },
            {
              type: "text",
              text: 'р╕Др╕ер╕┤р╕Бр╕Ыр╕╕р╣Ир╕б "р╕кр╣Ир╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╣Ар╕кр╕╡р╕вр╕З" р╕лр╕гр╕╖р╕н "р╕нр╕▒р╕Ыр╣Вр╕лр╕ер╕Фр╣Др╕Яр╕ер╣Мр╣Ар╕кр╕╡р╕вр╕З" р╣Бр╕ер╣Йр╕зр╕Юр╕╣р╕Фр╕лр╕гр╕╖р╕нр╕кр╣Ир╕Зр╣Др╕Яр╕ер╣Мр╣Ар╕кр╕╡р╕вр╕Зр╕Чр╕╡р╣Ир╕бр╕╡р╕Др╕│р╕Цр╕▓р╕бр╕лр╕гр╕╖р╕нр╣Ар╕Щр╕╖р╣Йр╕нр╕лр╕▓ р╕гр╕░р╕Ър╕Ър╕Ир╕░р╕Цр╕нр╕Фр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╣Ар╕кр╕╡р╕вр╕Зр╣Бр╕ер╕░р╣Гр╕лр╣Йр╕Др╕│р╕Хр╕нр╕Ър╕лр╕гр╕╖р╕нр╕кр╕гр╕╕р╕Ыр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Гр╕лр╣Й',
              wrap: true,
              margin: "sm",
            },
          ],
        },
      ],
    },
  },
}

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Ыр╕гр╕░р╣Ар╕ар╕Чр╕Хр╣Ир╕▓р╕Зр╣Ж
const handleMessage = async (event, userId, prompt, quoteToken) => {
  await line.loading(userId)
  const quickReply = {
    items: [
      {
        type: "action",
        action: { type: "message", label: "р╕кр╕зр╕▒р╕кр╕Фр╕╡ ЁЯЩМ", text: "р╕кр╕зр╕▒р╕кр╕Фр╕╡ ЁЯШБ" },
      },
      {
        type: "action",
        action: {
          type: "message",
          label: "р╕зр╕▒р╕Щр╕Щр╕╡р╣Йр╕зр╕▒р╕Щр╕Чр╕╡р╣Ир╣Ар╕Чр╣Ир╕▓р╣Др╕лр╕гр╣И? ЁЯУЕ",
          text: "р╕зр╕▒р╕Щр╕Щр╕╡р╣Йр╕зр╕▒р╕Щр╕Чр╕╡р╣Ир╣Ар╕Чр╣Ир╕▓р╣Др╕лр╕гр╣И",
        },
      },
      {
        type: "action",
        action: { type: "cameraRoll", label: "р╣Ар╕ер╕╖р╕нр╕Бр╕гр╕╣р╕Ыр╕ар╕▓р╕Ю ЁЯЦ╝я╕П" },
      },
      {
        type: "action",
        action: { type: "location", label: "р╕Др╕╕р╕Ур╕ар╕▓р╕Юр╕нр╕▓р╕Бр╕▓р╕ир╣Бр╕ер╕░р╕нр╕╕р╕Ур╕лр╕ар╕╣р╕бр╕┤ ЁЯМбя╕П" },
      },
      { type: "action", action: { type: "camera", label: "р╕Цр╣Ир╕▓р╕вр╕гр╕╣р╕Ы ЁЯУ╕" } },
      {
        type: "action",
        action: {
          type: "message",
          label: "р╕Ыр╕гр╕░р╣Вр╕вр╕Др╣Гр╕лр╣Йр╕Бр╕│р╕ер╕▒р╕Зр╣Гр╕И ЁЯТХ",
          text: "р╕Вр╕нр╕Ыр╕гр╕░р╣Вр╕вр╕Др╣Гр╕лр╣Йр╕Бр╕│р╕ер╕▒р╕Зр╣Гр╕Ир╣Гр╕Щр╕зр╕▒р╕Щр╕Чр╕╡р╣Ир╣Бр╕вр╣Ир╕лр╕гр╕╖р╕нр╣Ар╕лр╕Щр╕╖р╣Ир╕нр╕в,р╕лр╕бр╕Фр╕Бр╕│р╕ер╕▒р╕Зр╣Гр╕И",
        },
      },
    ],
  }

  if (event.message.mention && event.message.mention.mentionees) {
    const mentionPromises = event.message.mention.mentionees.map(
      async (mentionee) => {
        if (mentionee.isSelf === true) {
          await line.reply(
            event.replyToken,
            [
              {
                type: "textV2",
                text: "р╕зр╣Ир╕▓р╕вр╕▒р╕Зр╣Др╕Зр╕Др╕░ЁЯШК р╕Цр╕▓р╕бр╣Др╕Фр╣Йр╣Ар╕ер╕вр╕Щр╕░ЁЯШЙ {user1}",
                substitution: {
                  user1: {
                    type: "mention",
                    mentionee: { type: "user", userId: event.source.userId },
                  },
                },
                quoteToken: quoteToken,
              },
            ],
            quickReply
          )
        }
      }
    )
    await Promise.all(mentionPromises)
  }

  if (event.message.type === "text") {
    await handleTextMessage(event, prompt, quoteToken, quickReply)
  } else if (event.message.type === "image") {
    await handleImageMessage(event, quoteToken, quickReply)
  } else if (event.message.type === "audio") {
    await handleAudioMessage(event, quoteToken, quickReply)
  } else if (event.message.type === "location") {
    await handleLocationMessage(event, quoteToken, quickReply)
  }
}

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Ыр╕гр╕░р╣Ар╕ар╕Ч Text
const handleTextMessage = async (event, prompt, quoteToken, quickReply) => {
  const cacheKey = `text:${prompt}`
  const cachedText = webhookCache.get(cacheKey)
  if (cachedText) {
    await line.reply(
      event.replyToken,
      [{ type: "text", text: cachedText, quoteToken }],
      quickReply
    )
    return
  }
  try {
    const generatedText = isUrl(prompt)
      ? await queue.add(() => gemini.urlToText(prompt))
      : await queue.add(() => gemini.textOnly(prompt))
    webhookCache.set(cacheKey, generatedText, 600)
    await line.reply(
      event.replyToken,
      [{ type: "text", text: generatedText, quoteToken }],
      quickReply
    )
  } catch (error) {
    console.error("Error processing text message:", error)
    await line.reply(
      event.replyToken,
      [
        {
          type: "text",
          text: "р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕ер╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б",
          quoteToken,
        },
      ],
      quickReply
    )
  }
}

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Ыр╕гр╕░р╣Ар╕ар╕Ч Image
const handleImageMessage = async (event, quoteToken, quickReply) => {
  try {
    const ImageBinary = await line.getImageBinary(event.message.id)
    if (!ImageBinary) {
      await line.reply(
        event.replyToken,
        [{ type: "text", text: "р╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╕гр╕▒р╕Ър╕гр╕╣р╕Ыр╕ар╕▓р╕Юр╣Др╕Фр╣Й", quoteToken }],
        quickReply
      )
      return
    }
    const ImageBase64 = await sharp(ImageBinary)
      .resize(512, 512, { fit: "inside" })
      .toFormat("jpeg", { quality: 75 })
      .toBuffer()
      .then((data) => data.toString("base64"))
    const cacheKeyImage = `image:${ImageBase64}`
    const cachedImageText = webhookCache.get(cacheKeyImage)
    if (cachedImageText) {
      await line.reply(
        event.replyToken,
        [{ type: "text", text: cachedImageText, quoteToken }],
        quickReply
      )
      return
    }
    const generatedText = await imagetotext.multimodal(ImageBase64)
    webhookCache.set(cacheKeyImage, generatedText, 600)
    await line.reply(
      event.replyToken,
      [{ type: "text", text: generatedText, quoteToken }],
      quickReply
    )
  } catch (error) {
    console.error("р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕ер╕гр╕╣р╕Ыр╕ар╕▓р╕Ю:", error)
    await line.reply(
      event.replyToken,
      [{ type: "text", text: "р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕ер╕гр╕╣р╕Ыр╕ар╕▓р╕Ю", quoteToken }],
      quickReply
    )
  }
}

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Ыр╕гр╕░р╣Ар╕ар╕Ч Audio
const handleAudioMessage = async (event, quoteToken, quickReply) => {
  try {
    const messageId = event.message.id
    const audioFile = await line.getAudio(messageId)
    const timestamp = event.timestamp
    const m4aLocalFile = path.join(os.tmpdir(), `${timestamp}.m4a`)
    const wavLocalFile = path.join(os.tmpdir(), `${timestamp}.wav`)
    fs.writeFileSync(m4aLocalFile, audioFile)
    await convertM4aToWav(m4aLocalFile, wavLocalFile)
    const resultText = await transcribeSpeech(wavLocalFile)
    if (fs.existsSync(wavLocalFile)) fs.unlinkSync(wavLocalFile)
    const geminiResponse = await queue.add(() => gemini.textOnly(resultText))
    await line.reply(
      event.replyToken,
      [{ type: "text", text: geminiResponse, quoteToken }],
      quickReply
    )
  } catch (error) {
    console.error("р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕ер╣Др╕Яр╕ер╣Мр╣Ар╕кр╕╡р╕вр╕З:", error)
    await line.reply(event.replyToken, [
      {
        type: "text",
        text: "р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕ер╣Др╕Яр╕ер╣Мр╣Ар╕кр╕╡р╕вр╕З",
        quoteToken,
      },
    ])
  }
}

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Ыр╕гр╕░р╣Ар╕ар╕Ч Location
const handleLocationMessage = async (event, quoteToken, quickReply) => {
  const { latitude, longitude, address } = event.message
  const apiKey = "a15ac9f5-48e1-45f0-962a-81bb4af574c9" // **р╕Др╕зр╕гр╕вр╣Йр╕▓р╕вр╣Др╕Ыр╣Ар╕Бр╣Зр╕Ър╣Гр╕Щ Environment Variable**
  const apiUrl = `http://api.airvisual.com/v2/nearest_city?lat=${latitude}&lon=${longitude}&key=${apiKey}`
  try {
    const response = await fetch(apiUrl)
    const data = await response.json()
    if (data.status === "success") {
      const { tp, hu, ws, ic, pr } = data.data.current.weather
      const { aqius: aqi, maincn } = data.data.current.pollution
      let message = `ЁЯУН р╕кр╕Цр╕▓р╕Щр╕Чр╕╡р╣И: ${address}\n`
      message += `ЁЯМП р╕Юр╕┤р╕Бр╕▒р╕Ф: ${latitude}, ${longitude}\n`
      message += `тШБя╕П р╕кр╕ар╕▓р╕Юр╕нр╕▓р╕Бр╕▓р╕и: ${ic}\n`
      message += `ЁЯМбя╕П р╕нр╕╕р╕Ур╕лр╕ар╕╣р╕бр╕┤: ${tp}┬░C\n`
      message += `ЁЯТз р╕Др╕зр╕▓р╕бр╕Кр╕╖р╣Йр╕Щ: ${hu}%\n`
      message += `ЁЯТи р╕Др╕зр╕▓р╕бр╣Ар╕гр╣Зр╕зр╕ер╕б: ${ws} m/s\n`
      message += `ЁЯМА р╕Др╕зр╕▓р╕бр╕Бр╕Фр╕нр╕▓р╕Бр╕▓р╕и: ${pr} hPa\n\n`
      message += `ЁЯНГ р╕Др╕╕р╕Ур╕ар╕▓р╕Юр╕нр╕▓р╕Бр╕▓р╕и:\n`
      message += `AQI: ${aqi} (${getAQIDescription(aqi)})\n`
      message += `р╕бр╕ер╕Юр╕┤р╕йр╕Чр╕▓р╕Зр╕нр╕▓р╕Бр╕▓р╕ир╕лр╕ер╕▒р╕Б: ${maincn}\n\n`
      message += `р╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Ар╕Юр╕┤р╣Ир╕бр╣Ар╕Хр╕┤р╕бр╣Ар╕Бр╕╡р╣Ир╕вр╕зр╕Бр╕▒р╕Ъ AQI:\n`
      message += `- ${getAQIInfo(aqi)}\n`
      await line.reply(
        event.replyToken,
        [{ type: "text", text: message, quoteToken }],
        quickReply
      )
    } else {
      throw new Error(
        "IQAir API returned an error: " + JSON.stringify(data.data)
      )
    }
  } catch (error) {
    console.error("р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕кр╕ар╕▓р╕Юр╕нр╕▓р╕Бр╕▓р╕и:", error)
    await line.reply(
      event.replyToken,
      [
        {
          type: "text",
          text: "р╕Вр╕нр╕нр╕ар╕▒р╕в р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Др╕╕р╕Ур╕ар╕▓р╕Юр╕нр╕▓р╕Бр╕▓р╕и",
          quoteToken,
        },
      ],
      quickReply
    )
  }
}

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Др╕│р╕нр╕Шр╕┤р╕Ър╕▓р╕в AQI
const getAQIDescription = (aqi) => {
  if (aqi <= 50) return "р╕Фр╕╡"
  if (aqi <= 100) return "р╕Ыр╕▓р╕Щр╕Бр╕ер╕▓р╕З"
  if (aqi <= 150) return "р╕бр╕╡р╕Ьр╕ер╕Бр╕гр╕░р╕Чр╕Ър╕Хр╣Ир╕нр╕Бр╕ер╕╕р╣Ир╕бр╣Ар╕кр╕╡р╣Ир╕вр╕З"
  if (aqi <= 200) return "р╣Др╕бр╣Ир╕Фр╕╡р╕Хр╣Ир╕нр╕кр╕╕р╕Вр╕ар╕▓р╕Ю"
  if (aqi <= 300) return "р╣Бр╕вр╣Ир╕бр╕▓р╕Б"
  return "р╕нр╕▒р╕Щр╕Хр╕гр╕▓р╕в"
}

// р╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╣Гр╕лр╣Йр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Ар╕Юр╕┤р╣Ир╕бр╣Ар╕Хр╕┤р╕бр╣Ар╕Бр╕╡р╣Ир╕вр╕зр╕Бр╕▒р╕Ъ AQI
const getAQIInfo = (aqi) => {
  if (aqi <= 50) return "р╕Др╕╕р╕Ур╕ар╕▓р╕Юр╕нр╕▓р╕Бр╕▓р╕ир╕Фр╕╡р╕бр╕▓р╕Б р╣Ар╕лр╕бр╕▓р╕░р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕▓р╕гр╕Чр╕│р╕Бр╕┤р╕Ир╕Бр╕гр╕гр╕бр╕Бр╕ер╕▓р╕Зр╣Бр╕Ир╣Йр╕З"
  if (aqi <= 100)
    return "р╕Др╕╕р╕Ур╕ар╕▓р╕Юр╕нр╕▓р╕Бр╕▓р╕ир╕Ыр╕▓р╕Щр╕Бр╕ер╕▓р╕З р╕Др╕зр╕гр╕гр╕░р╕бр╕▒р╕Фр╕гр╕░р╕зр╕▒р╕Зр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Ьр╕╣р╣Йр╕Чр╕╡р╣Ир╕бр╕╡р╕Др╕зр╕▓р╕бр╣Др╕зр╕Хр╣Ир╕нр╕бр╕ер╕Юр╕┤р╕йр╕Чр╕▓р╕Зр╕нр╕▓р╕Бр╕▓р╕и"
  if (aqi <= 150)
    return "р╕Др╕╕р╕Ур╕ар╕▓р╕Юр╕нр╕▓р╕Бр╕▓р╕ир╣Ар╕гр╕┤р╣Ир╕бр╕бр╕╡р╕Ьр╕ер╕Бр╕гр╕░р╕Чр╕Ър╕Хр╣Ир╕нр╕кр╕╕р╕Вр╕ар╕▓р╕Ю р╕Ьр╕╣р╣Йр╕Ыр╣Ир╕зр╕вр╣Вр╕гр╕Др╕лр╕▒р╕зр╣Гр╕Ир╣Бр╕ер╕░р╕гр╕░р╕Ър╕Ър╕Чр╕▓р╕Зр╣Ар╕Фр╕┤р╕Щр╕лр╕▓р╕вр╣Гр╕Ир╕Др╕зр╕гр╕лр╕ер╕╡р╕Бр╣Ар╕ер╕╡р╣Ир╕вр╕Зр╕Бр╕▓р╕гр╕Чр╕│р╕Бр╕┤р╕Ир╕Бр╕гр╕гр╕бр╕Бр╕ер╕▓р╕Зр╣Бр╕Ир╣Йр╕З"
  if (aqi <= 200)
    return "р╕Др╕╕р╕Ур╕ар╕▓р╕Юр╕нр╕▓р╕Бр╕▓р╕ир╣Др╕бр╣Ир╕Фр╕╡р╕Хр╣Ир╕нр╕кр╕╕р╕Вр╕ар╕▓р╕Ю р╕Др╕зр╕гр╕ер╕Фр╕гр╕░р╕вр╕░р╣Ар╕зр╕ер╕▓р╕Бр╕▓р╕гр╕Чр╕│р╕Бр╕┤р╕Ир╕Бр╕гр╕гр╕бр╕Бр╕ер╕▓р╕Зр╣Бр╕Ир╣Йр╕З"
  if (aqi <= 300) return "р╕Др╕╕р╕Ур╕ар╕▓р╕Юр╕нр╕▓р╕Бр╕▓р╕ир╣Бр╕вр╣Ир╕бр╕▓р╕Б р╕лр╕ер╕╡р╕Бр╣Ар╕ер╕╡р╣Ир╕вр╕Зр╕Бр╕▓р╕гр╕Чр╕│р╕Бр╕┤р╕Ир╕Бр╕гр╕гр╕бр╕Бр╕ер╕▓р╕Зр╣Бр╕Ир╣Йр╕З"
  return "р╕Др╕╕р╕Ур╕ар╕▓р╕Юр╕нр╕▓р╕Бр╕▓р╕ир╕нр╕▒р╕Щр╕Хр╕гр╕▓р╕в р╕Зр╕Фр╕Бр╕▓р╕гр╕Чр╕│р╕Бр╕┤р╕Ир╕Бр╕гр╕гр╕бр╕Бр╕ер╕▓р╕Зр╣Бр╕Ир╣Йр╕З"
}

// --- р╕кр╣Ир╕зр╕Щр╕Чр╕╡р╣И 4: Express App р╣Бр╕ер╕░ Webhook Handler ---
const app = express()

// Middleware р╣Ар╕Юр╕╖р╣Ир╕нр╣Гр╕лр╣Й Express р╕кр╕▓р╕бр╕▓р╕гр╕Ц Parse JSON body р╕Чр╕╡р╣И LINE р╕кр╣Ир╕Зр╕бр╕▓р╣Др╕Фр╣Й
// LINE р╕нр╕▓р╕Ир╣Др╕бр╣Ир╣Др╕Фр╣Йр╕кр╣Ир╕З Content-Type р╕Чр╕╡р╣Ир╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕Зр╣Ар╕кр╕бр╕нр╣Др╕Ы р╕Бр╕▓р╕гр╣Др╕бр╣Ир╕гр╕░р╕Ър╕╕ type р╕Ир╕░р╕вр╕╖р╕Фр╕лр╕вр╕╕р╣Ир╕Щр╕Бр╕зр╣Ир╕▓
app.use(express.json())

// р╕кр╕гр╣Йр╕▓р╕З Route р╕кр╕│р╕лр╕гр╕▒р╕Ъ LINE Webhook
app.post("/webhook", async (req, res) => {
  const events = req.body.events
  if (!events || !Array.isArray(events)) {
    return res.status(400).send("Invalid event format")
  }

  // р╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕ер╕Чр╕╕р╕Б event р╣Бр╕Ър╕Ъ Asynchronous
  // р╣Ар╕гр╕▓р╕Ир╕░р╣Др╕бр╣Ир╕гр╕нр╣Гр╕лр╣Йр╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕ер╣Ар╕кр╕гр╣Зр╕Ир╕кр╕┤р╣Йр╕Щ р╣Бр╕Хр╣Ир╕Ир╕░р╕Хр╕нр╕Ъ 200 OK р╕Бр╕ер╕▒р╕Ър╣Др╕Ыр╣Гр╕лр╣Й LINE р╕Чр╕▒р╕Щр╕Чр╕╡
  Promise.all(
    events.map(async (event) => {
      const userId = event.source.userId
      console.log("Processing event for User ID: ", userId)
      try {
        if (event.type === "memberJoined") {
          await sendWelcomeMessage(event)
        } else if (event.type === "follow") {
          await sendWelcomeFlex(event, userId)
        } else if (event.type === "message") {
          const prompt = event.message.text?.trim() || ""
          if (prompt === "р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕гр╕░р╕Ър╕Ъ") {
            const systemInfo = getSystemInfo()
            const systemFlex = createSystemInfoFlex(systemInfo)
            await line.reply(event.replyToken, [systemFlex])
          } else if (prompt === "р╕Др╕╣р╣Ир╕бр╕╖р╕нр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ") {
            await line.reply(event.replyToken, [manualChatbot])
          } else {
            const quoteToken = event.message.quoteToken
            await handleMessage(event, userId, prompt, quoteToken)
          }
        }
      } catch (error) {
        console.error("Error processing event:", error)
      }
    })
  ).catch((err) => {
    console.error("Error in Promise.all execution:", err)
  })

  // р╕Хр╕нр╕Ър╕Бр╕ер╕▒р╕Ъ LINE р╕Чр╕▒р╕Щр╕Чр╕╡р╕Фр╣Йр╕зр╕в 200 OK р╣Ар╕Юр╕╖р╣Ир╕нр╣Бр╕Ир╣Йр╕Зр╕зр╣Ир╕▓р╣Др╕Фр╣Йр╕гр╕▒р╕Ъ event р╣Бр╕ер╣Йр╕з
  res.status(200).send("OK")
})

// --- р╕кр╣Ир╕зр╕Щр╕Чр╕╡р╣И 5: Export Handler р╕кр╕│р╕лр╕гр╕▒р╕Ъ AWS Lambda р╣Бр╕ер╕░ Server р╕кр╕│р╕лр╕гр╕▒р╕Ъ Local Development ---

// р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕зр╣Ир╕▓р╣Др╕бр╣Ир╣Др╕Фр╣Йр╕гр╕▒р╕Щр╕Ър╕Щ Lambda р╣Ар╕Юр╕╖р╣Ир╕нр╣Ар╕Ыр╕┤р╕Фр╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣Мр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Чр╕Фр╕кр╕нр╕Ър╕Ър╕Щр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕З
if (!process.env.AWS_LAMBDA_FUNCTION_NAME) {
  const PORT = process.env.PORT || 3000
  app.listen(PORT, () => {
    console.log(
      `тЬЕ Server is running for local development on http://localhost:${PORT}`
    )
    console.log("тЮбя╕П  Webhook endpoint: http://localhost:3000/webhook")
    console.log(
      "ЁЯТб Use ngrok to expose this port to the internet for LINE Webhook testing."
    )
  })
}

// Export Express app р╕Чр╕╡р╣Ир╕Цр╕╣р╕Бр╕лр╕╕р╣Йр╕бр╕Фр╣Йр╕зр╕в serverless-http р╣Ар╕Юр╕╖р╣Ир╕нр╣Гр╕лр╣Йр╕Чр╕│р╕Зр╕▓р╕Щр╕Ър╕Щ Lambda р╣Др╕Фр╣Й
export const handler = serverless(app)
